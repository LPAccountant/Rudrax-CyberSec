import asyncio
import socket
import ssl
import httpx
from dataclasses import dataclass

@dataclass
class ScanResult:
    tool: str
    target: str
    results: list[dict]
    status: str = "completed"
    error: str | None = None

async def port_scan(target: str, ports: str = "21,22,23,25,53,80,110,143,443,993,995,3306,3389,5432,8080,8443") -> ScanResult:
    results = []
    port_list = [int(p.strip()) for p in ports.split(",") if p.strip().isdigit()]
    for port in port_list:
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(target, port), timeout=2.0
            )
            results.append({"port": port, "state": "open", "service": get_service_name(port)})
            writer.close()
            await writer.wait_closed()
        except (asyncio.TimeoutError, ConnectionRefusedError, OSError):
            pass
    return ScanResult(tool="port_scanner", target=target, results=results)

def get_service_name(port: int) -> str:
    services = {
        21: "FTP", 22: "SSH", 23: "Telnet", 25: "SMTP", 53: "DNS",
        80: "HTTP", 110: "POP3", 143: "IMAP", 443: "HTTPS", 993: "IMAPS",
        995: "POP3S", 3306: "MySQL", 3389: "RDP", 5432: "PostgreSQL",
        8080: "HTTP-Alt", 8443: "HTTPS-Alt",
    }
    return services.get(port, "Unknown")

async def http_header_analysis(target: str) -> ScanResult:
    results = []
    url = target if target.startswith("http") else f"https://{target}"
    try:
        async with httpx.AsyncClient(timeout=15.0, verify=False, follow_redirects=True) as client:
            resp = await client.get(url)
            headers = dict(resp.headers)
            security_headers = {
                "Strict-Transport-Security": "Missing HSTS header",
                "Content-Security-Policy": "Missing CSP header",
                "X-Content-Type-Options": "Missing X-Content-Type-Options",
                "X-Frame-Options": "Missing X-Frame-Options",
                "X-XSS-Protection": "Missing X-XSS-Protection",
                "Referrer-Policy": "Missing Referrer-Policy",
                "Permissions-Policy": "Missing Permissions-Policy",
            }
            for header, warning in security_headers.items():
                h_lower = {k.lower(): v for k, v in headers.items()}
                if header.lower() in h_lower:
                    results.append({"header": header, "value": h_lower[header.lower()], "status": "present"})
                else:
                    results.append({"header": header, "value": None, "status": "missing", "warning": warning})
            if "server" in {k.lower() for k in headers}:
                server_val = next(v for k, v in headers.items() if k.lower() == "server")
                results.append({"header": "Server", "value": server_val, "status": "info", "warning": "Server header exposes software info"})
            results.append({"header": "Status Code", "value": str(resp.status_code), "status": "info"})
    except Exception as e:
        return ScanResult(tool="http_headers", target=target, results=[], status="error", error=str(e))
    return ScanResult(tool="http_headers", target=target, results=results)

async def ssl_check(target: str) -> ScanResult:
    hostname = target.replace("https://", "").replace("http://", "").split("/")[0].split(":")[0]
    results = []
    try:
        context = ssl.create_default_context()
        conn = context.wrap_socket(socket.socket(socket.AF_INET), server_hostname=hostname)
        conn.settimeout(10)
        conn.connect((hostname, 443))
        cert = conn.getpeercert()
        results.append({"field": "Subject", "value": str(cert.get("subject", ""))})
        results.append({"field": "Issuer", "value": str(cert.get("issuer", ""))})
        results.append({"field": "Version", "value": str(cert.get("version", ""))})
        results.append({"field": "Serial Number", "value": str(cert.get("serialNumber", ""))})
        results.append({"field": "Not Before", "value": str(cert.get("notBefore", ""))})
        results.append({"field": "Not After", "value": str(cert.get("notAfter", ""))})
        san = cert.get("subjectAltName", ())
        results.append({"field": "SANs", "value": ", ".join([v for _, v in san])})
        cipher = conn.cipher()
        if cipher:
            results.append({"field": "Cipher", "value": f"{cipher[0]} ({cipher[1]})"})
        results.append({"field": "Protocol", "value": conn.version() or "Unknown"})
        conn.close()
    except Exception as e:
        return ScanResult(tool="ssl_check", target=target, results=[], status="error", error=str(e))
    return ScanResult(tool="ssl_check", target=target, results=results)

async def directory_bruteforce(target: str, wordlist: list[str] | None = None) -> ScanResult:
    url = target if target.startswith("http") else f"https://{target}"
    url = url.rstrip("/")
    if wordlist is None:
        wordlist = [
            "admin", "login", "dashboard", "api", "wp-admin", "wp-login", "backup",
            "config", "test", "dev", "staging", "old", "new", "uploads", "images",
            "css", "js", "assets", "static", "media", "files", "documents", "data",
            ".env", ".git", "robots.txt", "sitemap.xml", ".htaccess", "web.config",
            "phpinfo.php", "info.php", "server-status", "server-info", "wp-content",
            "cgi-bin", "private", "secret", "hidden", "temp", "tmp", "logs", "log",
        ]
    results = []
    async with httpx.AsyncClient(timeout=10.0, verify=False, follow_redirects=False) as client:
        for path in wordlist:
            try:
                resp = await client.get(f"{url}/{path}")
                if resp.status_code < 404:
                    results.append({
                        "path": f"/{path}",
                        "status": resp.status_code,
                        "size": len(resp.content),
                    })
            except Exception:
                pass
    return ScanResult(tool="dir_bruteforce", target=target, results=results)

async def subdomain_scan(domain: str) -> ScanResult:
    subdomains = [
        "www", "mail", "ftp", "localhost", "webmail", "smtp", "pop", "ns1", "ns2",
        "dns", "dns1", "dns2", "mx", "mx1", "mx2", "api", "dev", "staging", "test",
        "admin", "portal", "blog", "shop", "store", "app", "m", "mobile", "cdn",
        "static", "assets", "img", "images", "media", "vpn", "remote", "git",
        "gitlab", "jenkins", "ci", "monitor", "status", "docs", "wiki", "help",
    ]
    results = []
    for sub in subdomains:
        full = f"{sub}.{domain}"
        try:
            answers = socket.getaddrinfo(full, None, socket.AF_INET)
            if answers:
                ip = answers[0][4][0]
                results.append({"subdomain": full, "ip": ip, "status": "found"})
        except (socket.gaierror, OSError):
            pass
    return ScanResult(tool="subdomain_scan", target=domain, results=results)

async def web_vulnerability_scan(target: str) -> ScanResult:
    url = target if target.startswith("http") else f"https://{target}"
    results = []
    try:
        async with httpx.AsyncClient(timeout=15.0, verify=False, follow_redirects=True) as client:
            resp = await client.get(url)
            headers = {k.lower(): v for k, v in resp.headers.items()}
            if "x-frame-options" not in headers:
                results.append({"vulnerability": "Clickjacking", "severity": "medium", "detail": "Missing X-Frame-Options header"})
            if "content-security-policy" not in headers:
                results.append({"vulnerability": "XSS Risk", "severity": "medium", "detail": "Missing Content-Security-Policy header"})
            if "strict-transport-security" not in headers:
                results.append({"vulnerability": "HSTS Missing", "severity": "medium", "detail": "HSTS not enforced"})
            if "x-content-type-options" not in headers:
                results.append({"vulnerability": "MIME Sniffing", "severity": "low", "detail": "Missing X-Content-Type-Options"})
            if "server" in headers:
                results.append({"vulnerability": "Server Info Leak", "severity": "info", "detail": f"Server: {headers['server']}"})
            if "x-powered-by" in headers:
                results.append({"vulnerability": "Tech Info Leak", "severity": "info", "detail": f"X-Powered-By: {headers['x-powered-by']}"})
            try:
                http_url = url.replace("https://", "http://")
                http_resp = await client.get(http_url, follow_redirects=False)
                if http_resp.status_code != 301 and http_resp.status_code != 302:
                    results.append({"vulnerability": "HTTP Not Redirected", "severity": "medium", "detail": "HTTP does not redirect to HTTPS"})
            except Exception:
                pass
            for test_path in ["/.env", "/.git/config", "/wp-config.php.bak", "/server-status"]:
                try:
                    r = await client.get(f"{url}{test_path}")
                    if r.status_code == 200:
                        results.append({"vulnerability": "Sensitive File Exposed", "severity": "high", "detail": f"Accessible: {test_path}"})
                except Exception:
                    pass
    except Exception as e:
        return ScanResult(tool="web_vuln_scan", target=target, results=[], status="error", error=str(e))
    if not results:
        results.append({"vulnerability": "None Found", "severity": "info", "detail": "No common vulnerabilities detected"})
    return ScanResult(tool="web_vuln_scan", target=target, results=results)
